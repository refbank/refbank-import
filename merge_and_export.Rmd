---
title: "Merge data and export"
output:
  html_document:
    toc: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message = F)
library(tidyverse)
library(here)
library(ggplot2)
library(stringi)
library(redivis)

# source(here("data_helpers.R"))
DATA_LOC=here("harmonized_data")
```

Set up the function for getting tables. 

```{r}
get_tbl <- function(con = DATA_LOC, dataset_name, tbl_name) {
  # con is fake rn, and takes in the root dir for all datasets
  if (missing(dataset_name)) {
    stop("dataset_name must be provided")
  }
  if (missing(tbl_name)) {
    stop("tbl_name must be provided")
  }
  
  file_path <- file.path(con, dataset_name, paste0(tbl_name, ".csv"))
  if (!file.exists(file_path)) {
    stop(paste("File does not exist:", file_path))
  }
  
  out <- read_csv(file_path, show_col_types = FALSE)
  
  out
}
```

# Make tables


Mark with dataset IDs

```{r, eval=F}
# options to get trials / choices / messages for all datasets
dataset_names <- list.dirs(DATA_LOC, full.names = FALSE) |> 
  stri_remove_empty()
```



Messages

Table messages {
  id integer [primary key]
  trial_id integer [foreign key trials]
  player_id integer [foreign key players]
  role varchar 
  text string
  message_number integer
  message_irrelevant bool
  time_stamp time
  dataset_id [foreign key datasets]
}

TODO check that player_id, trial_id, role, message_number, text, !is.na()

```{r}
messages <- map_df(dataset_names, \(d) get_tbl(DATA_LOC, d, "messages") |>
                     mutate(dataset_id = d))

na_messages <- messages |> filter(if_any(c("player_id", "trial_id", "role", "message_number", "text", "dataset_id"), is.na))
assert_that(nrow(na_messages)==0)
```



Trials

Table trials {
  id integer [primary key]
  condition_id integer [foreign key conditions]
  dataset_id [foreign key datasets]
  game_id varchar
  room_num varchar
  option_set list [foreign key images]
  target integer
  stage_num integer
  trial_num integer
  rep_num integer
  exclude bool
  exclusion_reason varchar
  describer varchar [foreign key players]
  matchers list [foreign key matchers]
}

TODO check that condition_id, game_id, room_num, option_set, target, stage_num, trial_num, rep_num, describer all !is.na()

```{r}
trials <-   map_df(dataset_names, \(d) get_tbl(DATA_LOC, d, "trials") |> 
                     mutate(target = as.character(target),
                            matchers = as.character(matchers),
                            dataset_id = d)) #|> 
 # mutate(option_set = option_set |> 
  #         str_remove_all("\\[|\\]|\"") |> 
   #        str_replace_all(",", ";") )

na_trials <- trials |> filter(if_any(c("condition_id", "game_id", "room_num", "option_set", "target", "stage_num", "trial_num", "rep_num", "describer", "dataset_id"), is.na))
assert_that(nrow(na_trials)==0)


```

Conditions & datasets


Table datasets{
  id integer [primary key]
  dataset_id varchar
  full_cite varchar
  short_cite varchar
}

Table conditions{
  id integer [primary key]
  dataset_id integer [foreign key datasets]
  group_size integer
  structure varchar
  language varchar
  placeholder_features varchar PLACEHOLDER
}

TODO check that dataset_id, full_cite, short_cite, condition_id, group_size, structure, language  all !is.na()

```{r}
conditions <- map_df(dataset_names, \(d) get_tbl(DATA_LOC, d, "conditions"))

datasets <- tibble(dataset_id = dataset_names) |>
  left_join(conditions |>
              select(dataset_id, full_cite, short_cite) |>
              distinct()) 

conditions <- conditions |>
  select(-full_cite, -short_cite)

na_datasets <- datasets |> filter(if_any(c("dataset_id", "full_cite", "short_cite"), is.na))
assert_that(nrow(na_datasets)==0)

na_conditions <- conditions |> filter(if_any(c("dataset_id", "condition_id", "group_size", "structure", "language"), is.na))
assert_that(nrow(na_conditions)==0)

```


Choices

Table choices {
  id integer [primary key]
  trial_id integer [foreign key trials]
  choice integer [foreign key images]
  player_id integer [foreign key players]
  time_to_choice time 
  dataset_id [foreign key datasets]
}

TODO check that trial_id, choice, player_id all !is.na()

```{r}
choices <- map_df(dataset_names, function (d) {
  df <- get_tbl(DATA_LOC, d, "choices")  |>
    mutate(player_id = as.numeric(player_id), 
           time_stamp = as.numeric(time_stamp),
           trial_id = as.numeric(trial_id),
           dataset_id = d) 
  
  df
}) 

na_choices <- choices |> filter(if_any(c("trial_id", "choice", "player_id"), is.na))
assert_that(nrow(na_choices)==0)
```

Players

Table players {
  id integer [primary key]
  age integer
  gender varchar
  placeholder_demo varchar
  dataset_id [foreign key datasets]
}

TODO check that player_id !is.na()

```{r}
players <- map_df(dataset_names, function (d) {
  df <- get_tbl(DATA_LOC, d, "players") |> 
    mutate(player_id=as.numeric(player_id),
           dataset_id=d)
  
  df
})

na_players <- players |> filter(if_any(c("player_id"), is.na))
assert_that(nrow(na_players)==0)
```

Images (already one table for all images)

Table images {
  id integer [primary key]
  kilogram_id varchar
  image_type varchar
  image_path varchar
}

check that id and image_type !is.na()

```{r}
images <- read_csv(here("image_data/image_metadata.csv"))

# keep here!
na_images <- images |> filter(if_any(c("image_id", "image_type"), is.na))
assert_that(nrow(na_images)==0)

```

# Validate

* all targets appear in images
* all images appear in option_list

* id cols are unique (and nest appropriately), & dataset id's line up

# Export

Write out for redivis with missing for NA to facilitate import. 

```{r}
write_csv(datasets, here("export", "datasets.csv"), na = "")
write_csv(messages, here("export", "messages.csv"), na = "")
write_csv(choices,  here("export", "choices.csv"), na = "")
write_csv(trials, here("export", "trials.csv"), na = "")
write_csv(conditions, here("export", "conditions.csv"), na = "")
```

Now try pushing them directly to redivis. 

```{r}
# Set up the connection to Redivis

con <- redivis::user("mcfrank")$dataset("refbank")

dataset <- con$create_next_version()

upload <- dataset$table("datasets")$upload()$create(
  "export/datasets.csv",
  type="delimited",        
  remove_on_fail = TRUE,     
  wait_for_finish = TRUE, 
  raise_on_fail = TRUE,
  replace_on_conflict = TRUE
)

upload <- dataset$table("datasets")$upload()$create(
  "export/messages.csv",
  type="delimited",        
  remove_on_fail = TRUE,     
  wait_for_finish = TRUE, 
  raise_on_fail = TRUE,
  replace_on_conflict = TRUE
)

upload <- dataset$table("datasets")$upload()$create(
  "export/choices.csv",
  type="delimited",        
  remove_on_fail = TRUE,     
  wait_for_finish = TRUE, 
  raise_on_fail = TRUE,
  replace_on_conflict = TRUE
)

upload <- dataset$table("datasets")$upload()$create(
  "export/trials.csv",
  type="delimited",        
  remove_on_fail = TRUE,     
  wait_for_finish = TRUE, 
  raise_on_fail = TRUE,
  replace_on_conflict = TRUE
)

upload <- dataset$table("datasets")$upload()$create(
  "export/conditions.csv",
  type="delimited",        
  remove_on_fail = TRUE,     
  wait_for_finish = TRUE, 
  raise_on_fail = TRUE,
  replace_on_conflict = TRUE
)

dataset$release()

  # 
# upload <- table$upload()$create(
#     "./data.csv",           # Path to file, data.frame, raw vector, etc
#     type="delimited",       # Inferred from file extension if not provided
#     remove_on_fail=True,    # Remove the upload if a failure occurs
#     wait_for_finish=True,   # Wait for the upload to finish processing
#     raise_on_fail=True      # Raise an error on failure
# )
```

